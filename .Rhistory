<<<<<<< HEAD
IrisTreePruned <- prune(IrisTree, cp = IrisTree$cptable[which.min(IrisTree$cptable[,"xerror"]),"CP"])
rpart.plot(IrisTreePruned)
##########################################################################################################
####################__________________   CART   __________________####################
##########################################################################################################
library(rpart)
library(rpart.plot)
# ?iris
# View(iris)
summary(iris)
?rpart
IrisTree <- rpart(Species ~ Sepal.Width + Sepal.Length + Petal.Width + Petal.Length, data = iris, control = rpart.control(minsplit = 0, cp = 0))
rpart.plot(IrisTree)
text(IrisTree)
IrisTree
#9 feuilles
plotcp(IrisTree)
IrisTreePruned <- prune(IrisTree, cp = IrisTree$cptable[which.min(IrisTree$cptable[,"xerror"]),"CP"])
rpart.plot(IrisTreePruned)
##########################################################################################################
####################__________________   CART   __________________####################
##########################################################################################################
library(rpart)
library(rpart.plot)
# ?iris
# View(iris)
summary(iris)
?rpart
IrisTree <- rpart(Species ~ Sepal.Width + Sepal.Length + Petal.Width + Petal.Length, data = iris, control = rpart.control(minsplit = 0, cp = 0))
rpart.plot(IrisTree)
text(IrisTree)
IrisTree
#9 feuilles
plotcp(IrisTree)
IrisTreePruned <- prune(IrisTree, cp = IrisTree$cptable[which.min(IrisTree$cptable[,"xerror"]),"CP"])
rpart.plot(IrisTreePruned)
##########################################################################################################
####################__________________   CART   __________________####################
##########################################################################################################
library(rpart)
library(rpart.plot)
# ?iris
# View(iris)
summary(iris)
?rpart
IrisTree <- rpart(Species ~ Sepal.Width + Sepal.Length + Petal.Width + Petal.Length, data = iris, control = rpart.control(minsplit = 0, cp = 0))
rpart.plot(IrisTree)
text(IrisTree)
IrisTree
#9 feuilles
plotcp(IrisTree)
IrisTreePruned <- prune(IrisTree, cp = IrisTree$cptable[which.min(IrisTree$cptable[,"xerror"]),"CP"])
rpart.plot(IrisTreePruned)
##########################################################################################################
####################__________________   CART   __________________####################
##########################################################################################################
library(rpart)
library(rpart.plot)
# ?iris
# View(iris)
summary(iris)
# ?rpart
IrisTree <- rpart(Species ~ Sepal.Width + Sepal.Length + Petal.Width + Petal.Length, data = iris, control = rpart.control(minsplit = 0, cp = 0))
rpart.plot(IrisTree)
text(IrisTree)
IrisTree
#9 feuilles
plotcp(IrisTree)
IrisTreePruned <- prune(IrisTree, cp = IrisTree$cptable[which.min(IrisTree$cptable[,"xerror"]),"CP"])
rpart.plot(IrisTreePruned)
##########################################################################################################
####################__________________   CART   __________________####################
##########################################################################################################
library(rpart)
library(rpart.plot)
# ?iris
# View(iris)
summary(iris)
# ?rpart
IrisTree <- rpart(Species ~ Sepal.Width + Sepal.Length + Petal.Width + Petal.Length, data = iris, control = rpart.control(minsplit = 0, cp = 0))
rpart.plot(IrisTree)
text(IrisTree)
IrisTree
#9 feuilles
plotcp(IrisTree)
IrisTreePruned <- prune(IrisTree, cp = IrisTree$cptable[which.min(IrisTree$cptable[,"xerror"]),"CP"])
rpart.plot(IrisTreePruned)
##########################################################################################################
####################__________________   CART   __________________####################
##########################################################################################################
library(rpart)
library(rpart.plot)
# ?iris
# View(iris)
summary(iris)
# ?rpart
IrisTree <- rpart(Species ~ Sepal.Width + Sepal.Length + Petal.Width + Petal.Length, data = iris, control = rpart.control(minsplit = 0, cp = 0))
rpart.plot(IrisTree)
text(IrisTree)
IrisTree
#9 feuilles
plotcp(IrisTree)
IrisTreePruned <- prune(IrisTree, cp = IrisTree$cptable[which.min(IrisTree$cptable[,"xerror"]),"CP"])
rpart.plot(IrisTreePruned)
cu <- data("cu.summary")
View(cu)
View(cu.summary)
summary(cu.summary)
library(dplyr)
CuTree <- rpart(data = cu.summary, Type ~ . , control = rpart.control(minsplit = 0, cp = 0)) %>%
rpart.plot()
?rpart
?vars
?var
var(CuTree$Price)
CuTree
IrisTree <- rpart(Species ~ Sepal.Width + Sepal.Length + Petal.Width + Petal.Length, method = "class", data = iris, control = rpart.control(minsplit = 0, cp = 0))
IrisTree <- rpart(Species ~ Sepal.Width + Sepal.Length + Petal.Width + Petal.Length, method = "class", data = iris, control = rpart.control(minsplit = 1,minbucket = 1, maxcompete = 2, xval = 5, cp = 0))
rpart.plot(IrisTree)
=======
length(logModel$fitted)
sup
logmModel$x
logModel$x
#----------- SARIMA (6,2,0)(1,1,0) ------------
#----- Identification des ordres -----
logphoto %>% diff(.,differences = 2) %>% diff(.,lag=12) %T>% ts.affichage(.,"photovolatique d=1, D=1") %>% kpss.test(.) #KPSS OK - EN FAIT JE COMPREND PAS CA
SARIMA620110<-arima(logphoto,order = c(6,2,0), seasonal = c(1,1,0)) #1 correspond à D=12 dans la seasonnalité
#----- Significativité des paramètres ----
(1-pnorm(abs(SARIMA620110$coef)/sqrt(diag(SARIMA620110$var.coef))))*2 <= 0.05 # OK
#----- Prévision ------
predict.SARIMA620110<-forecast(SARIMA620110)
#----- Vérification des hypothèses ----
acf(predict.SARIMA620110$residuals) #les résidus ont l'air stationnaires
pacf(predict.SARIMA620110$residuals) #pacf un peu limite...
predict.SARIMA620110.residuals.norm<- (residuals(predict.SARIMA620110)-mean(residuals(predict.SARIMA620110)))/sd(residuals(predict.SARIMA620110) )
#Test de normalité des résidus: Kolmogorov Smirnov
qqnorm(predict.SARIMA620110.residuals.norm)
abline(0,1, col = "red")
ks.test(predict.SARIMA620110.residuals.norm, 'pnorm') # OK (p-value>0.05)
#Test d'absence de correlation des résidus
Box.test(predict.SARIMA620110.residuals.norm) # OK
kpss.test(predict.SARIMA620110.residuals.norm) # OK
shapiro.test(predict.SARIMA620110.residuals.norm) # KO
#---- Affichage ----
logModel<-predict.SARIMA620110
logModel$x
logModel$fitted
logModel$mean
supError <- sup - logModel$mean
sup <- logModel$upper
inf <- logModel$lower
supError <- sup - logModel$mean
supError
ToExp<-function(logModel)
{
logSup <- logModel$upper
logInf <- logModel$lower
logMean <- logModel$mean
logSupError <- logSup - logMean
logInfError <- logMean - logInf
mean<- exp(logModel$mean)
logModel$x <- exp(logModel$x)
logModel$fitted <- exp(logModel$fitted)
logModel$mean <- mean
logModel$upper <- mean*(1+logSupError) #cas particulier de formule dans le cas log->exp
logModel$lower <- mean*(1-LogInfError)
return (logModel)
}
TEST <- ToExp(SARIMA620110)
rm(list=ls())
ToExp<-function(logModel)
{
logSup <- logModel$upper
logInf <- logModel$lower
logMean <- logModel$mean
logSupError <- logSup - logMean
logInfError <- logMean - logInf
mean<- exp(logModel$mean)
logModel$x <- exp(logModel$x)
logModel$fitted <- exp(logModel$fitted)
logModel$mean <- mean
logModel$upper <- mean*(1+logSupError) #cas particulier de formule dans le cas log->exp
logModel$lower <- mean*(1-LogInfError)
return (logModel)
}
rm(ToExp)
LogToExp<-function(logModel)
{
logSup <- logModel$upper
logInf <- logModel$lower
logMean <- logModel$mean
logSupError <- logSup - logMean
logInfError <- logMean - logInf
mean<- exp(logModel$mean)
logModel$x <- exp(logModel$x)
logModel$fitted <- exp(logModel$fitted)
logModel$mean <- mean
logModel$upper <- mean*(1+logSupError) #cas particulier de formule dans le cas log->exp
logModel$lower <- mean*(1-LogInfError)
return (logModel)
}
>>>>>>> c4932520c32af0144b81e33d77cad669dc855ec0
#### On en profite pour mettre en place les packages et les seeds.
library(knitr)
library(magrittr)
library(dplyr)
library(corrplot)
library(forecast)
library(gridExtra)
library(grid)
<<<<<<< HEAD
=======
library(gridExtra)
>>>>>>> c4932520c32af0144b81e33d77cad669dc855ec0
library(ggplot2)
library(tseries)
library(broom)
library(lattice)
<<<<<<< HEAD
library(forecast)
library(tseries)
=======
LogToExp<-function(logModel)
{
logSup <- logModel$upper
logInf <- logModel$lower
logMean <- logModel$mean
logSupError <- logSup - logMean
logInfError <- logMean - logInf
mean<- exp(logModel$mean)
logModel$x <- exp(logModel$x)
logModel$fitted <- exp(logModel$fitted)
logModel$mean <- mean
logModel$upper <- mean*(1+logSupError) #cas particulier de formule dans le cas log->exp
logModel$lower <- mean*(1-LogInfError)
return (logModel)
}
>>>>>>> c4932520c32af0144b81e33d77cad669dc855ec0
#fonctions utiles
ts.affichage <- function(ts, lag.max = 48,title="Mon titre"){
split.screen(c(2,1))
screen(1)
plot(ts,main=title)
split.screen(c(1,2),screen=2)
screen(3)
acf(ts,lag.max = lag.max,main="ACF",na.action = na.pass)
screen(4)
pacf(ts,lag.max = lag.max,main="pACF",na.action = na.pass)
close.screen(all = TRUE)
}
data <- read.csv("Donnees.csv", sep = ";", header = T)
#Introduction
#L'objet de ce projet est l'?tude de 3 s?ries temporelles et la construction pour chaque s?rie d'un mod?le de pr?diction. Tous les outils d?velopp?s dans ce projet d?coulent du cours de S?ries Temporelles.
#Nous commencerons par pr?senter les donn?es, puis nous r?serverons une partie d?di?e par s?rie temporelle a analyser. Enfin dans une derniere partie, nous r?sumerons les r?sultats des pr?dictions et les observations qu'elles appellent.
names(data) <- c("Periode",
"Production.Totale.Brute",
"Production.Totale.Nette",
"Production.Primaire.Brute",
"Production.Primaire.Nette",
"Production.Nucleaire.Brute",
"Production.Nucleaire.Nette",
"Production.Hydraulique.Brute",
"Production.Hydraulique.Nette",
"Production.Eolienne.Brute",
"Production.Eolienne.Nette",
"Production.Photovoltaique.Brute",
"Production.Photovoltaique.Nette",
"Production.Thermique.Brute",
"Production.Thermique.Nette",
"Electricite.absorbee.pour.les.pompages.(en.GWh)",
"Importations",
"Exportations",
"Energie.appelee.reelle.yc.pertes",
"Livraisons.BasseTension",
"Livraisons.MoyenneTension",
"Livraisons.HauteTension",
"Energie.appelee.reelle.yc.pertes.corrigee.du.climat",
"Livraisons.BasseTension.CorClimat",
"Livraisons.MoyenneTension.CorClimat",
"Consommation.Primaire",
"Consommation.Primaire.CorClimat",
"Puissance.maximale.appelee",
"Indice.Climatique"
)
ts <- list(prod.totale = ts(data$Production.Totale.Brute, frequency = 12, start = c(1981, 1), end = c(2017, 11)),
import = ts(data$Importations, frequency = 12,  start = c(1981,1), end = c(2017, 11)),
photo = ts(data$Production.Photovoltaique.Brute[data$Production.Photovoltaique.Brute!=0], frequency = 12, start = c(2011,1), end = c(2017,11)))
<<<<<<< HEAD
##############################################################################################
#############______   Partie 1: la production totale brute d'electricite   ______#############
##############################################################################################
##Representation.
setwd("~/ISFA/3A/Séries temporelles/ProjetSerieTemp")
#### On en profite pour mettre en place les packages et les seeds.
library(knitr)
library(magrittr)
library(dplyr)
library(corrplot)
library(forecast)
library(gridExtra)
library(grid)
library(ggplot2)
library(lattice)
library(forecast)
library(tseries)
#fonctions utiles
ts.affichage <- function(ts, lag.max = 48,title="Mon titre"){
split.screen(c(2,1))
screen(1)
plot(ts,main=title)
split.screen(c(1,2),screen=2)
screen(3)
acf(ts,lag.max = lag.max,main="ACF",na.action = na.pass)
screen(4)
pacf(ts,lag.max = lag.max,main="pACF",na.action = na.pass)
close.screen(all = TRUE)
}
data <- read.csv("Donnees.csv", sep = ";", header = T)
#Introduction
#L'objet de ce projet est l'?tude de 3 s?ries temporelles et la construction pour chaque s?rie d'un mod?le de pr?diction. Tous les outils d?velopp?s dans ce projet d?coulent du cours de S?ries Temporelles.
#Nous commencerons par pr?senter les donn?es, puis nous r?serverons une partie d?di?e par s?rie temporelle a analyser. Enfin dans une derniere partie, nous r?sumerons les r?sultats des pr?dictions et les observations qu'elles appellent.
names(data) <- c("Periode",
"Production.Totale.Brute",
"Production.Totale.Nette",
"Production.Primaire.Brute",
"Production.Primaire.Nette",
"Production.Nucleaire.Brute",
"Production.Nucleaire.Nette",
"Production.Hydraulique.Brute",
"Production.Hydraulique.Nette",
"Production.Eolienne.Brute",
"Production.Eolienne.Nette",
"Production.Photovoltaique.Brute",
"Production.Photovoltaique.Nette",
"Production.Thermique.Brute",
"Production.Thermique.Nette",
"Electricite.absorbee.pour.les.pompages.(en.GWh)",
"Importations",
"Exportations",
"Energie.appelee.reelle.yc.pertes",
"Livraisons.BasseTension",
"Livraisons.MoyenneTension",
"Livraisons.HauteTension",
"Energie.appelee.reelle.yc.pertes.corrigee.du.climat",
"Livraisons.BasseTension.CorClimat",
"Livraisons.MoyenneTension.CorClimat",
"Consommation.Primaire",
"Consommation.Primaire.CorClimat",
"Puissance.maximale.appelee",
"Indice.Climatique"
)
ts <- list(prod.totale = ts(data$Production.Totale.Brute, frequency = 12, start = c(1981, 1), end = c(2017, 11)),
import = ts(data$Importations, frequency = 12,  start = c(1981,1), end = c(2017, 11)),
photo = ts(data$Production.Photovoltaique.Brute[data$Production.Photovoltaique.Brute!=0], frequency = 12, start = c(2011,1), end = c(2017,11)))
##############################################################################################
#############______   Partie 1: la production totale brute d'electricite   ______#############
##############################################################################################
##Representation.
plot(ts$prod.totale, ylab = "Production totale d'electricite brute", type = "l")
par(mfrow = c(1,2))
acf(ts$prod.totale)
pacf(ts$prod.totale)
decompose.prod.totale <- decompose(ts$prod.totale, type = "additive") %T>% plot(.)
acf(decompose.prod.totale$random, na.action = na.pass)
pacf(decompose.prod.totale$random, na.action = na.pass)
close.screen(all = T)
ts$prod.totale %>% diff(.,12) %T>% ts.affichage(title = "Production Brute Total d=0, D=1") %>% kpss.test(.)
#On différencie alors encore et on test la stationnarité
ts$prod.totale %>% diff() %>% diff(.,12) %T>% ts.affichage(title = "Production Brute Total d=1, D=1") %>% kpss.test(.)
#On enregistre alors la série différenciée
prod.totale.mod1 <- ts$prod.totale %>% diff() %>% diff(.,12)
#On fit donc un SARIMA(1,1,1)(1,1,1)_12
fit <- arima(ts$prod.totale, order=c(1,1,1), seasonal=c(1,1,1))
#On fit donc un SARIMA(1,1,1)(1,1,1)_12
fit <- arima(ts$prod.totale, order=c(4,1,1), seasonal=c(3,1,1))
ts.affichage(residuals(fit), title = "Résidus SARIMA(4,1,1)(3,1,1)")
fit
#On fit donc un SARIMA(1,1,1)(1,1,1)_12
fit <- arima(ts$prod.totale, order=c(4,1,1), seasonal=c(2,1,1))
ts.affichage(residuals(fit), title = "Résidus SARIMA(4,1,1)(2,1,1)")
fit
ts.affichage(residuals(fit), title = "Résidus SARIMA(4,1,1)(1,1,1)")
fit
#On fit donc un SARIMA(1,1,1)(1,1,1)_12
fit <- arima(ts$prod.totale, order=c(4,1,1), seasonal=c(1,1,1))
ts.affichage(residuals(fit), title = "Résidus SARIMA(4,1,1)(1,1,1)")
fit
#On fit donc un SARIMA(1,1,1)(1,1,1)_12
fit <- arima(ts$prod.totale, order=c(1,1,1), seasonal=c(0,1,1))
ts.affichage(residuals(fit), title = "Résidus SARIMA(1,1,1)(0,1,1)")
fit
#On test la stationnarité des résidus
kpss.test(residuals(fit))
x <- rep(0, 2, 48)
for (i in 1:48){
x[i]<- Box.test(residuals(fit), lag=i, fitdf=3, type="Ljung")$p.value
}
plot(x)
x[i]<- Box.test(residuals(fit), lag=i, type="Ljung")$p.value
x <- rep(0, 2, 48)
for (i in 1:48){
x[i]<- Box.test(residuals(fit), lag=i, type="Ljung")$p.value
}
plot(x)
#On fit donc un SARIMA(1,1,1)(1,1,1)_12
fit <- arima(ts$prod.totale, order=c(1,1,1), seasonal=c(1,1,1))
ts.affichage(residuals(fit), title = "Résidus SARIMA(1,1,1)(0,1,1)")
fit
#On test la stationnarité des résidus
kpss.test(residuals(fit))
fit
#Il nous faut tester la blancheur des résidus
#Test Ljung-Box
x <- rep(0, 2, 48)
x <- rep(0, 2, 48)
for (i in 1:48){
x[i]<- Box.test(residuals(fit), lag=i, type="Ljung")$p.value
}
plot(x)
X
x
#On enregistre alors la série différenciée
prod.totale.mod1 <- ts$prod.totale %>% diff() %>% diff(.,12)
#On différencie alors encore et on test la stationnarité
ts$prod.totale %>% diff() %>% diff(.,12) %T>% ts.affichage(title = "Production Brute Total d=1, D=1") %>% kpss.test(.)
?diff
ts$prod.totale %>% diff() %>% diff()
ts$prod.totale %>% diff(.,differences = 2)
#On enregistre alors la série différenciée
prod.totale.mod1 <- ts$prod.totale %>% diff(.,differences = 2) %>% diff(.,12)
#On différencie alors encore et on test la stationnarité
ts$prod.totale %>% diff(.,differences = 2) %>% diff(.,lag = 12) %T>% ts.affichage(title = "Production Brute Total d=1, D=1") %>% kpss.test(.)
#On enregistre alors la série différenciée
prod.totale.mod1 <- ts$prod.totale %>% diff(.,differences = 2) %>% diff(.,12)
#On fit donc un SARIMA(1,1,1)(1,1,1)_12
fit <- arima(ts$prod.totale, order=c(1,2,1), seasonal=c(1,1,1))
ts.affichage(residuals(fit), title = "Résidus SARIMA(1,1,1)(0,1,1)")
fit
#On fit donc un SARIMA(1,1,1)(1,1,1)_12
fit <- arima(ts$prod.totale, order=c(1,2,1), seasonal=c(0,1,1))
ts.affichage(residuals(fit), title = "Résidus SARIMA(1,1,1)(0,1,1)")
fit
#On fit donc un SARIMA(1,1,1)(1,1,1)_12
fit <- arima(ts$prod.totale, order=c(2,2,1), seasonal=c(0,1,1))
ts.affichage(residuals(fit), title = "Résidus SARIMA(1,1,1)(0,1,1)")
fit
#On fit donc un SARIMA(1,1,1)(1,1,1)_12
fit <- arima(ts$prod.totale, order=c(4,2,1), seasonal=c(0,1,1))
ts.affichage(residuals(fit), title = "Résidus SARIMA(1,1,1)(0,1,1)")
fit
#On fit donc un SARIMA(1,1,1)(1,1,1)_12
fit <- arima(ts$prod.totale, order=c(6,2,1), seasonal=c(0,1,1))
ts.affichage(residuals(fit), title = "Résidus SARIMA(1,1,1)(0,1,1)")
fit
#On fit donc un SARIMA(1,1,1)(1,1,1)_12
fit <- arima(ts$prod.totale, order=c(5,2,1), seasonal=c(0,1,1))
ts.affichage(residuals(fit), title = "Résidus SARIMA(1,1,1)(0,1,1)")
fit
#On fit donc un SARIMA(1,1,1)(1,1,1)_12
fit <- arima(ts$prod.totale, order=c(5,2,1), seasonal=c(1,1,1))
ts.affichage(residuals(fit), title = "Résidus SARIMA(1,1,1)(0,1,1)")
fit
#On fit donc un SARIMA(1,1,1)(1,1,1)_12
fit <- arima(ts$prod.totale, order=c(5,2,2), seasonal=c(0,1,1))
ts.affichage(residuals(fit), title = "Résidus SARIMA(1,1,1)(0,1,1)")
fit
#On test la stationnarité des résidus
kpss.test(residuals(fit))
x <- rep(0, 2, 48)
for (i in 1:48){
x[i]<- Box.test(residuals(fit), lag=i, type="Ljung")$p.value
}
plot(x)
x>=0.05
### Test de normalité
#on centre et réduit les résidus:
prod.totale.fit.res.norm <- (residuals(fit)-mean(residuals(fit)))/sd(residuals(fit))
#qq plot test: il faut que ce soit aligné sur la première bissectrice du plan
qqnorm(prod.totale.fit.res.norm)
abline(0,1, col = "red")
#Test de Kolmogorov Smirnov
ks.test(prod.totale.fit.res.norm, 'pnorm') #on accepte (p-value > 0.05)
#Test de Shapiro-Wilk
shapiro.test(prod.totale.fit.res.norm) #on refuse (p-value < 0.05). Cela est probablement du aux queues de distribution
#On projette sur 12 mois
predict.arima <- forecast(fit, h=12)
test <- auto.arima(ts$prod.totale, d=1, D=1)
test
test <- auto.arima(ts$prod.totale)
test
residuals(test)%>%shapiro.test()
test%>%ks.test(.,y = 'pnorm')
test%>%ks.test(.,y = "pnorm")
test%>%residuals(.)%>%ks.test(.,y = "pnorm")
ks.test(x = rnorm(10000), y = "pnorm")
#On différencie alors encore et on test la stationnarité
ts$prod.totale %>% diff(.,differences = 1) %>% diff(.,lag = 12) %T>% ts.affichage(title = "Production Brute Total d=1, D=1") %>% kpss.test(.)
#On enregistre alors la série différenciée
prod.totale.mod1 <- ts$prod.totale %>% diff(.,differences = 1) %>% diff(.,12)
#On fit donc un SARIMA(1,1,1)(1,1,1)_12
fit <- arima(ts$prod.totale, order=c(0,1,1), seasonal=c(0,1,1))
ts.affichage(residuals(fit), title = "Résidus SARIMA(1,1,1)(0,1,1)")
#On fit donc un SARIMA(1,1,1)(1,1,1)_12
fit <- arima(ts$prod.totale, order=c(0,1,1), seasonal=c(1,1,1))
ts.affichage(residuals(fit), title = "Résidus SARIMA(1,1,1)(0,1,1)")
#On fit donc un SARIMA(1,1,1)(1,1,1)_12
fit <- arima(ts$prod.totale, order=c(1,1,1), seasonal=c(,1,1))
#On fit donc un SARIMA(1,1,1)(1,1,1)_12
fit <- arima(ts$prod.totale, order=c(1,1,1), seasonal=c(0,1,1))
ts.affichage(residuals(fit), title = "Résidus SARIMA(1,1,1)(0,1,1)")
#On test la stationnarité des résidus
kpss.test(residuals(fit))
x <- rep(0, 2, 48)
for (i in 1:48){
x[i]<- Box.test(residuals(fit), lag=i, type="Ljung")$p.value
}
plot(x)
x>0.05
### Test de normalité
#on centre et réduit les résidus:
prod.totale.fit.res.norm <- (residuals(fit)-mean(residuals(fit)))/sd(residuals(fit))
#qq plot test: il faut que ce soit aligné sur la première bissectrice du plan
qqnorm(prod.totale.fit.res.norm)
abline(0,1, col = "red")
#Test de Kolmogorov Smirnov
ks.test(prod.totale.fit.res.norm, 'pnorm') #on accepte (p-value > 0.05)
#Test de Shapiro-Wilk
shapiro.test(prod.totale.fit.res.norm) #on refuse (p-value < 0.05). Cela est probablement du aux queues de distribution
#Test de Kolmogorov Smirnov
ks.test(residuals(fit), 'pnorm') #on accepte (p-value > 0.05)
#Test de Shapiro-Wilk
shapiro.test(prod.totale.fit.res.norm) #on refuse (p-value < 0.05). Cela est probablement du aux queues de distribution
#On différencie alors encore et on test la stationnarité
ts$prod.totale %>% diff(.,differences = 1) %>% diff(.,lag = 12) %T>% ts.affichage(title = "Production Brute Total d=1, D=1") %>% kpss.test(.)
#On fit donc un SARIMA(1,1,1)(1,1,1)_12
fit <- arima(ts$prod.totale, order=c(0,1,1), seasonal=c(0,1,0))
ts.affichage(residuals(fit), title = "Résidus SARIMA(1,1,1)(0,1,1)")
fit
#On fit donc un SARIMA(1,1,1)(1,1,1)_12
fit <- arima(ts$prod.totale, order=c(0,1,1), seasonal=c(4,1,0))
ts.affichage(residuals(fit), title = "Résidus SARIMA(1,1,1)(0,1,1)")
fit
#On fit donc un SARIMA(1,1,1)(1,1,1)_12
fit <- arima(ts$prod.totale, order=c(0,1,1), seasonal=c(0,1,1))
ts.affichage(residuals(fit), title = "Résidus SARIMA(1,1,1)(0,1,1)")
#On fit donc un SARIMA(1,1,1)(1,1,1)_12
fit <- arima(ts$prod.totale, order=c(0,1,1), seasonal=c(0,1,0))
ts.affichage(residuals(fit), title = "Résidus SARIMA(1,1,1)(0,1,1)")
#On fit donc un SARIMA(1,1,1)(1,1,1)_12
fit <- arima(ts$prod.totale, order=c(0,1,1), seasonal=c(1,1,0))
ts.affichage(residuals(fit), title = "Résidus SARIMA(1,1,1)(0,1,1)")
#On différencie alors encore et on test la stationnarité
ts$prod.totale %>% diff(.,differences = 1) %>% diff(.,lag = 12) %T>% ts.affichage(title = "Production Brute Total d=1, D=1") %>% kpss.test(.)
#On fit donc un SARIMA(1,1,1)(1,1,1)_12
fit <- arima(ts$prod.totale, order=c(0,1,0), seasonal=c(4,1,0))
ts.affichage(residuals(fit), title = "Résidus SARIMA(1,1,1)(0,1,1)")
#On fit donc un SARIMA(1,1,1)(1,1,1)_12
fit <- arima(ts$prod.totale, order=c(0,1,1), seasonal=c(4,1,0))
ts.affichage(residuals(fit), title = "Résidus SARIMA(1,1,1)(0,1,1)")
#On fit donc un SARIMA(1,1,1)(1,1,1)_12
fit <- arima(ts$prod.totale, order=c(4,1,1), seasonal=c(0,1,0))
ts.affichage(residuals(fit), title = "Résidus SARIMA(1,1,1)(0,1,1)")
#On fit donc un SARIMA(1,1,1)(1,1,1)_12
fit <- arima(ts$prod.totale, order=c(4,1,1), seasonal=c(0,1,1))
ts.affichage(residuals(fit), title = "Résidus SARIMA(1,1,1)(0,1,1)")
#On test la stationnarité des résidus
kpss.test(residuals(fit))
fit
#On fit donc un SARIMA(1,1,1)(1,1,1)_12
fit <- arima(ts$prod.totale, order=c(3,1,1), seasonal=c(0,1,1))
fit
#On fit donc un SARIMA(1,1,1)(1,1,1)_12
fit <- arima(ts$prod.totale, order=c(2,1,1), seasonal=c(0,1,1))
fit
#On fit donc un SARIMA(1,1,1)(1,1,1)_12
fit <- arima(ts$prod.totale, order=c(1,1,1), seasonal=c(0,1,1))
ts.affichage(residuals(fit), title = "Résidus SARIMA(1,1,1)(0,1,1)")
fit
x <- rep(0, 2, 48)
for (i in 1:48){
x[i]<- Box.test(residuals(fit), lag=i, type="Ljung")$p.value
}
plot(x)
### Test de normalité
#on centre et réduit les résidus:
prod.totale.fit.res.norm <- (residuals(fit)-mean(residuals(fit)))/sd(residuals(fit))
#qq plot test: il faut que ce soit aligné sur la première bissectrice du plan
qqnorm(prod.totale.fit.res.norm)
abline(0,1, col = "red")
#Test de Kolmogorov Smirnov
ks.test(prod.totale.fit.res.norm, 'pnorm') #on accepte (p-value > 0.05)
#Test de Shapiro-Wilk
shapiro.test(prod.totale.fit.res.norm) #on refuse (p-value < 0.05). Cela est probablement du aux queues de distribution
install.packages"("strucchange)
install.packages("strucchange")
maserie <- ts$import
plot(maserie);
abline(v=time(maserie)[breakpoints(maserie~1,breaks=1)$breakpoints],col="red")
library(strucchange)
abline(v=time(maserie)[breakpoints(maserie~1,breaks=1)$breakpoints],col="red")
breakpoints(maserie~1,breaks=1)$breakpoints
?breakpoints
breakpoints(maserie~1,breaks=1)$breakpoints/12
#On différencie alors encore et on test la stationnarité
ts$prod.totale %>% diff(.,differences = 1) %>% diff(.,lag = 12) %T>% ts.affichage(title = "Production Brute Total d=1, D=1") %>% kpss.test(.)
ts$prod.totale %>% diff(.,12) %T>% ts.affichage(title = "Production Brute Total d=0, D=1") %>% kpss.test(.)
#On fit donc un SARIMA(1,1,1)(1,1,1)_12
fit <- arima(ts$prod.totale, order=c(1,1,1), seasonal=c(0,1,1))
ts.affichage(residuals(fit), title = "Résidus SARIMA(1,1,1)(0,1,1)")
fit
#On test la stationnarité des résidus
kpss.test(residuals(fit))
fit
#Il nous faut tester la blancheur des résidus
#Test Ljung-Box
x <- rep(0, 2, 48)
#On projette sur 12 mois
predict.arima <- forecast(fit, h=12)
#On plot
plot(predict.arima)
=======
plot(ts$photo)            # Modèle à priori multiplicatif
logphoto <- log(ts$photo) # On passe au log pour homogeneiser la variance et passer dans un modèle additif
plot(logphoto)            # Ok , ca semble additif
logphoto.decompose<-decompose(logphoto)
plot(logphoto.decompose)  # Saisonnalité 12
acf(logphoto) #Pas stationnaire
pacf(logphoto)
ts.affichage(logphoto)
kpss.test(logphoto.decompose$random) #la partie aleatoire de la série décomposée est stationnaire
#----- Identification des ordres -----
logphoto %>% diff(.,differences = 1) %>% diff(.,lag=12) %T>% ts.affichage(.,"photovolatique d=1, D=1") %>% kpss.test(.) #KPSS OK - EN FAIT JE COMPREND PAS CA
SARIMA210110<-arima(logphoto,order = c(2,1,0), seasonal = c(1,1,0)) #1 correspond à D=12 dans la seasonnalité
#----- Significativité des paramètres ----
(1-pnorm(abs(SARIMA210110$coef)/sqrt(diag(SARIMA210110$var.coef))))*2 <= 0.05 # OK
#----- Prévision ------
predict.SARIMA210110<-forecast(SARIMA210110)
#----- Vérification des hypothèses ----
acf(predict.SARIMA210110$residuals) #les résidus ont l'air stationnaires
pacf(predict.SARIMA210110$residuals) #pacf un peu limite...
predict.SARIMA210110.residuals.norm<- (residuals(predict.SARIMA210110)-mean(residuals(predict.SARIMA210110)))/sd(residuals(predict.SARIMA210110) )
#Test de normalité des résidus: Kolmogorov Smirnov
qqnorm(predict.SARIMA210110.residuals.norm)
abline(0,1, col = "red")
ks.test(predict.SARIMA210110.residuals.norm, 'pnorm') # OK (p-value>0.05)
#Test d'absence de correlation des résidus
Box.test(predict.SARIMA210110.residuals.norm) # OK
kpss.test(predict.SARIMA210110.residuals.norm) # OK
shapiro.test(predict.SARIMA210110.residuals.norm) # KO
#---- Affichage ----
exp.predict.SARIMA210110 <- LogToExp(predict.SARIMA210110)
logModel <- SARIMA210110
logSup <- logModel$upper
logInf <- logModel$lower
logMean <- logModel$mean
logSupError <- logSup - logMean
logInfError <- logMean - logInf
mean<- exp(logModel$mean)
logModel <- predict.SARIMA210110
logSup <- logModel$upper
logInf <- logModel$lower
logMean <- logModel$mean
logSupError <- logSup - logMean
logInfError <- logMean - logInf
mean<- exp(logModel$mean)
logModel$x <- exp(logModel$x)
logModel$fitted <- exp(logModel$fitted)
logModel$mean <- mean
logModel$upper <- mean*(1+logSupError) #cas particulier de formule dans le cas log->exp
logModel$lower <- mean*(1-LogInfError)
LogToExp<-function(logModel)
{
logSup <- logModel$upper
logInf <- logModel$lower
logMean <- logModel$mean
logSupError <- logSup - logMean
logInfError <- logMean - logInf
mean<- exp(logModel$mean)
logModel$x <- exp(logModel$x)
logModel$fitted <- exp(logModel$fitted)
logModel$mean <- mean
logModel$upper <- mean*(1+logSupError) #cas particulier de formule dans le cas log->exp
logModel$lower <- mean*(1-LogInfError)
return (logModel)
}
rm(logModel)
plot(ts$photo)            # Modèle à priori multiplicatif
logphoto <- log(ts$photo) # On passe au log pour homogeneiser la variance et passer dans un modèle additif
plot(logphoto)            # Ok , ca semble additif
logphoto.decompose<-decompose(logphoto)
plot(logphoto.decompose)  # Saisonnalité 12
acf(logphoto) #Pas stationnaire
pacf(logphoto)
ts.affichage(logphoto)
kpss.test(logphoto.decompose$random) #la partie aleatoire de la série décomposée est stationnaire
#----- Identification des ordres -----
logphoto %>% diff(.,differences = 1) %>% diff(.,lag=12) %T>% ts.affichage(.,"photovolatique d=1, D=1") %>% kpss.test(.) #KPSS OK - EN FAIT JE COMPREND PAS CA
SARIMA210110<-arima(logphoto,order = c(2,1,0), seasonal = c(1,1,0)) #1 correspond à D=12 dans la seasonnalité
#----- Significativité des paramètres ----
(1-pnorm(abs(SARIMA210110$coef)/sqrt(diag(SARIMA210110$var.coef))))*2 <= 0.05 # OK
#----- Prévision ------
predict.SARIMA210110<-forecast(SARIMA210110)
#----- Vérification des hypothèses ----
acf(predict.SARIMA210110$residuals) #les résidus ont l'air stationnaires
pacf(predict.SARIMA210110$residuals) #pacf un peu limite...
predict.SARIMA210110.residuals.norm<- (residuals(predict.SARIMA210110)-mean(residuals(predict.SARIMA210110)))/sd(residuals(predict.SARIMA210110) )
#Test de normalité des résidus: Kolmogorov Smirnov
qqnorm(predict.SARIMA210110.residuals.norm)
abline(0,1, col = "red")
ks.test(predict.SARIMA210110.residuals.norm, 'pnorm') # OK (p-value>0.05)
#Test d'absence de correlation des résidus
Box.test(predict.SARIMA210110.residuals.norm) # OK
kpss.test(predict.SARIMA210110.residuals.norm) # OK
shapiro.test(predict.SARIMA210110.residuals.norm) # KO
#---- Affichage ----
exp.predict.SARIMA210110 <- LogToExp(predict.SARIMA210110)
LogToExp<-function(logModel)
{
logSup <- logModel$upper
logInf <- logModel$lower
logMean <- logModel$mean
logSupError <- logSup - logMean
logInfError <- logMean - logInf
mean<- exp(logModel$mean)
logModel$x <- exp(logModel$x)
logModel$fitted <- exp(logModel$fitted)
logModel$mean <- mean
logModel$upper <- mean*(1+logSupError) #cas particulier de formule dans le cas log->exp
logModel$lower <- mean*(1-LogInfError)
return (logModel)
}
LogToExp<-function(logModel)
{
logSup <- logModel$upper
logInf <- logModel$lower
logMean <- logModel$mean
logSupError <- logSup - logMean
logInfError <- logMean - logInf
mean<- exp(logModel$mean)
logModel$x <- exp(logModel$x)
logModel$fitted <- exp(logModel$fitted)
logModel$mean <- mean
logModel$upper <- mean*(1+logSupError) #cas particulier de formule dans le cas log->exp
logModel$lower <- mean*(1-logInfError)
return (logModel)
}
plot(ts$photo)            # Modèle à priori multiplicatif
logphoto <- log(ts$photo) # On passe au log pour homogeneiser la variance et passer dans un modèle additif
plot(logphoto)            # Ok , ca semble additif
logphoto.decompose<-decompose(logphoto)
plot(logphoto.decompose)  # Saisonnalité 12
acf(logphoto) #Pas stationnaire
pacf(logphoto)
ts.affichage(logphoto)
SARIMA210110<-arima(logphoto,order = c(2,1,0), seasonal = c(1,1,0)) #1 correspond à D=12 dans la seasonnalité
#----- Significativité des paramètres ----
(1-pnorm(abs(SARIMA210110$coef)/sqrt(diag(SARIMA210110$var.coef))))*2 <= 0.05 # OK
#----- Prévision ------
predict.SARIMA210110<-forecast(SARIMA210110)
#----- Identification des ordres -----
logphoto %>% diff(.,differences = 1) %>% diff(.,lag=12) %T>% ts.affichage(.,"photovolatique d=1, D=1") %>% kpss.test(.) #KPSS OK - EN FAIT JE COMPREND PAS CA
pacf(predict.SARIMA210110$residuals) #pacf un peu limite...
kpss.test(logphoto.decompose$random) #la partie aleatoire de la série décomposée est stationnaire
#----- Vérification des hypothèses ----
acf(predict.SARIMA210110$residuals) #les résidus ont l'air stationnaires
predict.SARIMA210110.residuals.norm<- (residuals(predict.SARIMA210110)-mean(residuals(predict.SARIMA210110)))/sd(residuals(predict.SARIMA210110) )
#Test de normalité des résidus: Kolmogorov Smirnov
qqnorm(predict.SARIMA210110.residuals.norm)
abline(0,1, col = "red")
#Test d'absence de correlation des résidus
Box.test(predict.SARIMA210110.residuals.norm) # OK
ks.test(predict.SARIMA210110.residuals.norm, 'pnorm') # OK (p-value>0.05)
kpss.test(predict.SARIMA210110.residuals.norm) # OK
shapiro.test(predict.SARIMA210110.residuals.norm) # KO
#---- Affichage ----
exp.predict.SARIMA210110 <- LogToExp(predict.SARIMA210110)
#On passe repasse à l'exponentiel
predict.SARIMA210110$lower <- exp(predict.SARIMA210110$lower)
predict.SARIMA210110$upper <- exp(predict.SARIMA210110$upper)
plot(ts$photo)            # Modèle à priori multiplicatif
logphoto <- log(ts$photo) # On passe au log pour homogeneiser la variance et passer dans un modèle additif
plot(logphoto)            # Ok , ca semble additif
logphoto.decompose<-decompose(logphoto)
acf(logphoto) #Pas stationnaire
plot(logphoto.decompose)  # Saisonnalité 12
pacf(logphoto)
ts.affichage(logphoto)
kpss.test(logphoto.decompose$random) #la partie aleatoire de la série décomposée est stationnaire
#----- Identification des ordres -----
logphoto %>% diff(.,differences = 1) %>% diff(.,lag=12) %T>% ts.affichage(.,"photovolatique d=1, D=1") %>% kpss.test(.) #KPSS OK - EN FAIT JE COMPREND PAS CA
SARIMA210110<-arima(logphoto,order = c(2,1,0), seasonal = c(1,1,0)) #1 correspond à D=12 dans la seasonnalité
#----- Significativité des paramètres ----
(1-pnorm(abs(SARIMA210110$coef)/sqrt(diag(SARIMA210110$var.coef))))*2 <= 0.05 # OK
#----- Prévision ------
predict.SARIMA210110<-forecast(SARIMA210110)
#----- Vérification des hypothèses ----
acf(predict.SARIMA210110$residuals) #les résidus ont l'air stationnaires
pacf(predict.SARIMA210110$residuals) #pacf un peu limite...
predict.SARIMA210110.residuals.norm<- (residuals(predict.SARIMA210110)-mean(residuals(predict.SARIMA210110)))/sd(residuals(predict.SARIMA210110) )
#Test de normalité des résidus: Kolmogorov Smirnov
qqnorm(predict.SARIMA210110.residuals.norm)
abline(0,1, col = "red")
ks.test(predict.SARIMA210110.residuals.norm, 'pnorm') # OK (p-value>0.05)
#Test d'absence de correlation des résidus
Box.test(predict.SARIMA210110.residuals.norm) # OK
kpss.test(predict.SARIMA210110.residuals.norm) # OK
shapiro.test(predict.SARIMA210110.residuals.norm) # KO
#---- Affichage ----
exp.predict.SARIMA210110 <- LogToExp(predict.SARIMA210110)
plot(exp.predict.SARIMA210110)
plot(predict.SARIMA210110)
#---- Affichage ----
exp.predict.SARIMA210110 <- LogToExp(predict.SARIMA210110)
plot(exp.predict.SARIMA210110)
#---- Affichage ----
exp.predict.SARIMA210110 <- LogToExp(predict.SARIMA210110)
plot(exp.predict.SARIMA210110)
#On passe repasse à l'exponentiel
predict.SARIMA210110$lower <- exp(predict.SARIMA210110$lower)
predict.SARIMA210110$upper <- exp(predict.SARIMA210110$upper)
predict.SARIMA210110$x <- exp(predict.SARIMA210110$x)
predict.SARIMA210110$fitted <- exp(predict.SARIMA210110$fitted)
predict.SARIMA210110$mean <- exp(predict.SARIMA210110$mean)
plot(predict.SARIMA210110)
plot(exp.predict.SARIMA210110)
plot(predict.SARIMA210110)
plot(exp.predict.SARIMA210110)
plot(exp.predict.SARIMA210110)
#----- Identification des ordres -----
logphoto %>% diff(.,differences = 1) %>% diff(.,lag=12) %T>% ts.affichage(.,"photovolatique d=1, D=1") %>% kpss.test(.) #KPSS OK - EN FAIT JE COMPREND PAS CA
SARIMA210110<-arima(logphoto,order = c(2,1,0), seasonal = c(1,1,0)) #1 correspond à D=12 dans la seasonnalité
#----- Significativité des paramètres ----
(1-pnorm(abs(SARIMA210110$coef)/sqrt(diag(SARIMA210110$var.coef))))*2 <= 0.05 # OK
#----- Prévision ------
predict.SARIMA210110<-forecast(SARIMA210110)
#----- Vérification des hypothèses ----
acf(predict.SARIMA210110$residuals) #les résidus ont l'air stationnaires
pacf(predict.SARIMA210110$residuals) #pacf un peu limite...
predict.SARIMA210110.residuals.norm<- (residuals(predict.SARIMA210110)-mean(residuals(predict.SARIMA210110)))/sd(residuals(predict.SARIMA210110) )
#Test de normalité des résidus: Kolmogorov Smirnov
qqnorm(predict.SARIMA210110.residuals.norm)
abline(0,1, col = "red")
ks.test(predict.SARIMA210110.residuals.norm, 'pnorm') # OK (p-value>0.05)
#Test d'absence de correlation des résidus
Box.test(predict.SARIMA210110.residuals.norm) # OK
kpss.test(predict.SARIMA210110.residuals.norm) # OK
shapiro.test(predict.SARIMA210110.residuals.norm) # KO
#---- Affichage ----
exp.predict.SARIMA210110 <- LogToExp(predict.SARIMA210110)
plot(ts$photo)            # Modèle à priori multiplicatif
logphoto <- log(ts$photo) # On passe au log pour homogeneiser la variance et passer dans un modèle additif
plot(logphoto)            # Ok , ca semble additif
logphoto.decompose<-decompose(logphoto)
plot(logphoto.decompose)  # Saisonnalité 12
acf(logphoto) #Pas stationnaire
pacf(logphoto)
ts.affichage(logphoto)
kpss.test(logphoto.decompose$random) #la partie aleatoire de la série décomposée est stationnaire
#----------- SARIMA (2,1,0)(1,1,0) ------------
#----- Identification des ordres -----
logphoto %>% diff(.,differences = 1) %>% diff(.,lag=12) %T>% ts.affichage(.,"photovolatique d=1, D=1") %>% kpss.test(.) #KPSS OK - EN FAIT JE COMPREND PAS CA
#On identifie alors les composantes:
# ordre de différentiation: d = 1
# composante AR : q = 1 - En effet, l'ACF decroit exponentiellement vite et les autocorrelations sont nulles après 1
# composante MA : p = 0 - Il n'y a apparemment pas de composante en MA à retenir (A vérifier - tester)
# Y a-t-il des composantes saisonnières ? TODO
SARIMA210110<-arima(logphoto,order = c(2,1,0), seasonal = c(1,1,0)) #1 correspond à D=12 dans la seasonnalité
#----- Significativité des paramètres ----
(1-pnorm(abs(SARIMA210110$coef)/sqrt(diag(SARIMA210110$var.coef))))*2 <= 0.05 # OK
#----- Prévision ------
predict.SARIMA210110<-forecast(SARIMA210110)
#----- Vérification des hypothèses ----
acf(predict.SARIMA210110$residuals) #les résidus ont l'air stationnaires
pacf(predict.SARIMA210110$residuals) #pacf un peu limite...
predict.SARIMA210110.residuals.norm<- (residuals(predict.SARIMA210110)-mean(residuals(predict.SARIMA210110)))/sd(residuals(predict.SARIMA210110) )
#Test de normalité des résidus: Kolmogorov Smirnov
qqnorm(predict.SARIMA210110.residuals.norm)
abline(0,1, col = "red")
ks.test(predict.SARIMA210110.residuals.norm, 'pnorm') # OK (p-value>0.05)
#Test d'absence de correlation des résidus
Box.test(predict.SARIMA210110.residuals.norm) # OK
kpss.test(predict.SARIMA210110.residuals.norm) # OK
shapiro.test(predict.SARIMA210110.residuals.norm) # KO
#On passe repasse à l'exponentiel
predict.SARIMA210110$lower <- exp(predict.SARIMA210110$lower)
predict.SARIMA210110$upper <- exp(predict.SARIMA210110$upper)
predict.SARIMA210110$x <- exp(predict.SARIMA210110$x)
predict.SARIMA210110$fitted <- exp(predict.SARIMA210110$fitted)
predict.SARIMA210110$mean <- exp(predict.SARIMA210110$mean)
plot(predict.SARIMA210110)
#---- Affichage ----
exp.predict.SARIMA210110 <- LogToExp(predict.SARIMA210110)
plot(exp.predict.SARIMA210110)
plot(exp.predict.SARIMA210110)
plot(ts$photo)            # Modèle à priori multiplicatif
logphoto <- log(ts$photo) # On passe au log pour homogeneiser la variance et passer dans un modèle additif
plot(logphoto)            # Ok , ca semble additif
logphoto.decompose<-decompose(logphoto)
plot(logphoto.decompose)  # Saisonnalité 12
acf(logphoto) #Pas stationnaire
pacf(logphoto)
ts.affichage(logphoto)
kpss.test(logphoto.decompose$random) #la partie aleatoire de la série décomposée est stationnaire
#----------- SARIMA (2,1,0)(1,1,0) ------------
#----- Identification des ordres -----
logphoto %>% diff(.,differences = 1) %>% diff(.,lag=12) %T>% ts.affichage(.,"photovolatique d=1, D=1") %>% kpss.test(.) #KPSS OK - EN FAIT JE COMPREND PAS CA
#On identifie alors les composantes:
# ordre de différentiation: d = 1
# composante AR : q = 1 - En effet, l'ACF decroit exponentiellement vite et les autocorrelations sont nulles après 1
# composante MA : p = 0 - Il n'y a apparemment pas de composante en MA à retenir (A vérifier - tester)
# Y a-t-il des composantes saisonnières ? TODO
SARIMA210110<-arima(logphoto,order = c(2,1,0), seasonal = c(1,1,0)) #1 correspond à D=12 dans la seasonnalité
#----- Significativité des paramètres ----
(1-pnorm(abs(SARIMA210110$coef)/sqrt(diag(SARIMA210110$var.coef))))*2 <= 0.05 # OK
#----- Prévision ------
predict.SARIMA210110<-forecast(SARIMA210110)
#----- Vérification des hypothèses ----
acf(predict.SARIMA210110$residuals) #les résidus ont l'air stationnaires
pacf(predict.SARIMA210110$residuals) #pacf un peu limite...
predict.SARIMA210110.residuals.norm<- (residuals(predict.SARIMA210110)-mean(residuals(predict.SARIMA210110)))/sd(residuals(predict.SARIMA210110) )
#Test de normalité des résidus: Kolmogorov Smirnov
qqnorm(predict.SARIMA210110.residuals.norm)
abline(0,1, col = "red")
ks.test(predict.SARIMA210110.residuals.norm, 'pnorm') # OK (p-value>0.05)
#Test d'absence de correlation des résidus
Box.test(predict.SARIMA210110.residuals.norm) # OK
kpss.test(predict.SARIMA210110.residuals.norm) # OK
shapiro.test(predict.SARIMA210110.residuals.norm) # KO
#---- Affichage ----
exp.predict.SARIMA210110 <- LogToExp(predict.SARIMA210110)
plot(exp.predict.SARIMA210110)
#----- Identification des ordres -----
logphoto %>% diff(.,differences = 2) %>% diff(.,lag=12) %T>% ts.affichage(.,"photovolatique d=1, D=1") %>% kpss.test(.) #KPSS OK - EN FAIT JE COMPREND PAS CA
SARIMA620110<-arima(logphoto,order = c(6,2,0), seasonal = c(1,1,0)) #1 correspond à D=12 dans la seasonnalité
#----- Significativité des paramètres ----
(1-pnorm(abs(SARIMA620110$coef)/sqrt(diag(SARIMA620110$var.coef))))*2 <= 0.05 # OK
#----- Prévision ------
predict.SARIMA620110<-forecast(SARIMA620110)
#----- Vérification des hypothèses ----
acf(predict.SARIMA620110$residuals) #les résidus ont l'air stationnaires
pacf(predict.SARIMA620110$residuals) #pacf un peu limite...
predict.SARIMA620110.residuals.norm<- (residuals(predict.SARIMA620110)-mean(residuals(predict.SARIMA620110)))/sd(residuals(predict.SARIMA620110) )
#Test de normalité des résidus: Kolmogorov Smirnov
qqnorm(predict.SARIMA620110.residuals.norm)
abline(0,1, col = "red")
ks.test(predict.SARIMA620110.residuals.norm, 'pnorm') # OK (p-value>0.05)
#Test d'absence de correlation des résidus
Box.test(predict.SARIMA620110.residuals.norm) # OK
kpss.test(predict.SARIMA620110.residuals.norm) # OK
shapiro.test(predict.SARIMA620110.residuals.norm) # KO
#---- Affichage ----
exp.predict.SARIMA620110 <- LogToExp(predict.SARIMA620110)
plot(exp.predict.SARIMA620110)
#----------- SARIMA (5,2,0)(1,1,0) ------------
#----- Identification des ordres -----
logphoto %>% diff(.,differences = 2) %>% diff(.,lag=12) %T>% ts.affichage(.,"photovolatique d=1, D=1") %>% kpss.test(.) #KPSS OK - EN FAIT JE COMPREND PAS CA
SARIMA520110<-arima(logphoto,order = c(5,2,0), seasonal = c(1,1,0)) #1 correspond à D=12 dans la seasonnalité
#----- Significativité des paramètres ----
(1-pnorm(abs(SARIMA520110$coef)/sqrt(diag(SARIMA520110$var.coef))))*2 <= 0.05 # OK
#----- Prévision ------
predict.SARIMA520110<-forecast(SARIMA520110)
#----- Vérification des hypothèses ----
acf(predict.SARIMA520110$residuals) #les résidus ont l'air stationnaires
pacf(predict.SARIMA520110$residuals) #pacf un peu limite...
predict.SARIMA520110.residuals.norm<- (residuals(predict.SARIMA520110)-mean(residuals(predict.SARIMA520110)))/sd(residuals(predict.SARIMA520110) )
#Test de normalité des résidus: Kolmogorov Smirnov
qqnorm(predict.SARIMA520110.residuals.norm)
abline(0,1, col = "red")
ks.test(predict.SARIMA520110.residuals.norm, 'pnorm') # OK (p-value>0.05)
#Test d'absence de correlation des résidus
Box.test(predict.SARIMA520110.residuals.norm) # OK
kpss.test(predict.SARIMA520110.residuals.norm) # OK
shapiro.test(predict.SARIMA520110.residuals.norm) # KO
#---- Affichage ----
#---- Affichage ----
exp.predict.SARIMA520110 <- LogToExp(predict.SARIMA520110)
plot(exp.predict.SARIMA520110)
>>>>>>> c4932520c32af0144b81e33d77cad669dc855ec0
